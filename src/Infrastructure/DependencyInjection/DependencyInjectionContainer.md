# Dependency Injection Container

1. What    
1.1 What is a Dependency Injection container?    
1.3 What tools are we using in order to accomplish this?    
1.2 How it works
2. Why    
2.1 Why do we need it?
3. Usage    
3.1 How do I get a service from the container?    
3.2 How do I get access to the container?    
3.3 How do I register a class in the container?    
3.4 Known Issues to be aware of.


## 1. What
#### 1.1 What is a Dependency Injection Container?
A Dependency Injection container is at it's most basic level a persistent map of cached services that you may use throughout your application.
If you need an Endpoint constructor somewhere in a service, you can query it from the container. 

Containers also embody in many cases business logic, because when you ask the container for an 'Abstraction' 
(for Example, an HttpClientInterface), instead of a 'Concretion', (for Example, an HttpClient), 
then the container has the right to decide which concrete class to give you. And of course you are totally in control of that.

For example, in the test Environment, you may want to pass a `MockHttpClient` to all of your
classes that query the `HttpClientInterface` so your tests don't make real Http calls during tests. 
But in order to do this all you need to do is change the container registration.

#### 1.2 What tools are we using to Accomplish this?
[Inversify.io](https://inversifyjs.io)
and [Reflect-Metadata](https://github.com/rbuckton/reflect-metadata)

Inversify.io is the most popular Typescript-based dependency Injection containers there by far.
Reflect-metadata is required by the container as it polyfills a not-yet released feature
for using metadata about objects generated by @annotations.

#### 1.3 How does it work?
The container is created and loaded at the start time of the application, as the service bindings need to be loaded
before any components or classes use the container. Therefore, in `BaseRoot`, we call the `ApplicationLoader` to 
create the container and then bind all the services to it.

Then, you can simply use the container anywhere you want. (Ok, not just anywhere, you need to think carefully about it.)

For more info see the section on Usage (3.1-3.3)

## 2. Why?
#### 2.1 Why do we need it?

We don't technically need it. We also don't need React! But it encourages SOLID principle adherence in that 
it encourages us to program against interfaces and work towards top-down management of our code which is emphasized in the
'Dependency Inversion' section of 'SOLID'.

This article is helpful in understanding: http://php-di.org/doc/understanding-di.html


## 3. Usage:
Don't let this be a substitute for reading the [Documentation](https://github.com/inversify/InversifyJS) more in-depth if you want to work with the container.



### 3.1 How do I get a service from the Container? 
Basic Example:
```
import container from '../../../Container/instance.ts'

class MyCoolClass {
    public constructor(
        private httpClient: HttpClient = container.get<HttpClient>(HttpClient)
    ){}

    public doStuff() {
        this.httpClient.fetchFrom(// whatever);
    }
}
```
The style we currently use is 'container.get'. 

This can should be done with interfaces as often as possible:
```
import container from '../../../Container/instance.ts'

class MyCoolClass {
    public constructor(
        private httpClient: HttpClientInterface = container.get<HttpClientInterface>(ServiceId.HttpClientInterface)
    ){}

    public doStuff() {
        this.httpClient.fetchFrom(// whatever);
    }
}
```
There is a file in the Container Folder called 'ServiceId', which contains Symbol based
Ids that the container has been instructed to map to specific class concretions.

### 3.2 How do I get access to the container?

Simply require the container from `instance.ts`.  In Most IDEs, you can
simply type 'container', and the IDE will autoimport it.  Import it and then use it as explained above.


### 3.3 How do I register a class in the Container?

IMPORTANT: All classes with the `@injectable()` decorator above them
are already auto-loaded into the container. You don't need to register them. So if you create a class
called `MyCoolService`, and place an `injectable()` decorator over it, it will already be in the container to be queried with 
`container.get<MyCoolService>(MyCoolService)`.

But, and you should try to do this, if you want to create a `MyCoolServiceInterface` to which you will bind a class,
then you need to create a new ID in `ServiceId` file, following the existing naming schema.

Then, you need to go to `ContainerLoader.ts`, and bind your interface like the other interfaces are bound there.

`container.bind<MyCoolServiceInterface>(ServiceId.MyCoolServiceInterface).to(MyCoolService)`

Take note that our container is set up to make some bindings in global, testing, production, and development environments. The workflow
should be fairly straightforward. Place your binding in the environment you need it to be in, but take care that
you also bind this interface to a concrete class in ALL environments, as if you only bind it in testing, 
then your tests will pass, but the interface will be bound to nothing in production.

### 3.4 Known Issues to be aware of:
1. Constructor parameter injection `@inject(MyCoolService) private myService` is theoretically supported by
inversifyJs, but it is not supported by the babel configurations of Create-react-app. Therefore, we cannot use them yet. (We should keep an eye on TC39 Decorator Support)
2. Doing lower level things in Javascript can sometimes lead to circular references and the 'Temporal Dead Zone. If you have a class that requires the container, 
and the container requires that class (for example, to inject the class in a specific context), then in the container file the class import
will be undefined.  Because Webpack realizes that it needs to parse 'instance.js' to parse, i.e. `MyCoolService.ts`, and in order to parse 
`instance.ts`, it needs to parse `MyCoolService.ts`, webpack detects a Temporal Dead Zone (TDZ) error
and simply gives up, leaving your class undefined.
    
    In our setup this should be theoretically completely avoided, because the file from which the container
is imported contains no references to any other classes.

    This has, however, one downside, namely that the import of the container does not guarantee it is fully configured. 
    The construction and configuration of the container must exist in a separate file from the file which exports the container, otherwise a class
    may find itself importing `container.ts` and `container.ts` importing that file. This means we have some tests written to ensure
    that the container configuration is carried out on app mount. It must also be run in the tests in `setupTests.ts`
